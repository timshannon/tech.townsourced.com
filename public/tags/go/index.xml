<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Townsourced Tech Blog</title>
    <link>http://tech.townsourced.com/tags/go/index.xml</link>
    <description>Recent content on Townsourced Tech Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <atom:link href="http://tech.townsourced.com/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Anatomy of a Go Web App - Part 2: Authentication</title>
      <link>http://tech.townsourced.com/post/anatomy-of-a-go-web-app-authentication/</link>
      <pubDate>Sun, 15 Jan 2017 19:05:51 -0600</pubDate>
      
      <guid>http://tech.townsourced.com/post/anatomy-of-a-go-web-app-authentication/</guid>
      <description>&lt;p&gt;This is part two of a set of posts breaking down some of the decisions I made when putting together the web server for
&lt;a href=&#34;https://www.townsourced.com&#34;&gt;townsourced&lt;/a&gt;.  The first part is &lt;a href=&#34;http://tech.townsourced.com/post/anatomy-of-a-go-web-app/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Instead of a general overview, like part one, this post will focus specifically on &lt;strong&gt;User Authentication&lt;/strong&gt;, i.e. how to
handle passwords (if at all) and session management.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;password-management&#34;&gt;Password Management&lt;/h1&gt;

&lt;p&gt;The best, and most secure system for managing passwords in a web app is &lt;em&gt;not to manage passwords at all&lt;/em&gt;.  The most secure
and bulletproof password system is still vulnerable to your user&amp;rsquo;s fallibility, and as you&amp;rsquo;ll see when we go over password
management below, most of the work goes into trying to protect the users from themselves.&lt;/p&gt;

&lt;p&gt;So, how do you get out of the password management business?  You offload the work to trusted third parties.  This usually
means integrating &lt;a href=&#34;https://en.wikipedia.org/wiki/OAuth&#34;&gt;OAUTH&lt;/a&gt; into your authentication code.&lt;/p&gt;

&lt;h2 id=&#34;oauth&#34;&gt;OAUTH&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ll want to use popular third parties through which your users will probably already have accounts set up. My policy is
to give users as many options as possible so that the simplest option for them is to &lt;em&gt;not&lt;/em&gt; create a password in my app.&lt;br /&gt;
This means adding OAUTH support for one or more of the &lt;strong&gt;Big Three&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Facebook&lt;/strong&gt;: &lt;a href=&#34;https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow&#34;&gt;Manually Build a Login Flow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Google&lt;/strong&gt;: &lt;a href=&#34;https://developers.google.com/identity/sign-in/web/server-side-flow&#34;&gt;Google Sign-In for server-side apps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Twitter&lt;/strong&gt;: &lt;a href=&#34;https://dev.twitter.com/web/sign-in/implementing&#34;&gt;Implementing Sign in with Twitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This will not be a detailed overview of implementing OAUTH, there are
&lt;a href=&#34;https://aaronparecki.com/2012/07/29/2/oauth2-simplified&#34;&gt;better articles&lt;/a&gt; out there for that.  I will, however, step
you through the pieces you need to have in place in order to get it working.  A very high level overview of OAUTH looks
like this (courtesy of Google):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tech.townsourced.com/images/post/anatomy-of-a-go-web-app-authentication/server_side_code_flow.png&#34; alt=&#34;OAUTH2 Server Side Flow&#34; title=&#34;Server Side Code Flow&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Facebook and Google are very similar, and you should be able to get by with a standard
&lt;a href=&#34;https://github.com/golang/oauth2&#34;&gt;OAUTH2 library&lt;/a&gt; (with a little bit of tweaking).  Twitter, on the other hand, actually
uses &lt;em&gt;OAUTH1.0A&lt;/em&gt;, so you&amp;rsquo;ll need to make sure you use a library built for it like
&lt;a href=&#34;https://github.com/mrjones/oauth&#34;&gt;https://github.com/mrjones/oauth&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Each of the &lt;strong&gt;Big Three&lt;/strong&gt; have a unique user identifier that you can store with your &lt;a href=&#34;http://tech.townsourced.com/post/anatomy-of-a-go-web-app/#the-app-package&#34;&gt;user record&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package app

...


type User struct {
	Username       data.Key        
	Email          string          
	...
	GoogleID       string         
	FacebookID     string        
	TwitterID      string       
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And once that&amp;rsquo;s in place, you can do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package app

...


// FacebookUser gets a user (if possible) from the passed in facebook code
func FacebookUser(redirectURI, code string) (*User, error) {
	fbSes, err := facebookGetSession(redirectURI, code)
	if err != nil {
		return nil, err
	}
	//Lookup user in the database
	usr, err := userGetFacebook(fbSes.userID)
	if err == ErrUserNotFound {
		data, err := fbSes.userData()
		if err != nil {
			return nil, err
		}

		// Create new user from Facebook data
		...
		return newUser, ErrUserNotFound
	}
	if err != nil {
		return nil, err
	}

	// Return user and log them in
	return usr, nil
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your Google and Twitter functions will look very similar.  Check if a user already exists, associated to the given
third party credentials, and if so, log them in, otherwise use the information shared (or accessible via some other API)
to build a new user.&lt;/p&gt;

&lt;h2 id=&#34;passwords&#34;&gt;Passwords&lt;/h2&gt;

&lt;p&gt;If for some reason your user does not want to use a third party login, or you aren&amp;rsquo;t permitted to offer them in your app
(for instance internal, non-internet facing apps), you&amp;rsquo;ll need to securely manage your user&amp;rsquo;s passwords.&lt;/p&gt;

&lt;h3 id=&#34;requirements&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;There is a lot of discussion, and argument over password best practices, and I highly recommend doing your own research,
and getting a good understanding of the implications of some of these decisions before starting.  Once again, the best
option is to &lt;em&gt;not to manage passwords at all&lt;/em&gt;. That being said, here is a short list of best practices I try to meet when
setting my password requirements.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Longer passwords are better than complex passwords

&lt;ul&gt;
&lt;li&gt;Skip doing any complexity checks, or requiring a minimum level of entropy, or at least one number, special
symbols, etc&lt;/li&gt;
&lt;li&gt;Minimum password length should be 10, or even better 12 (as of 2016).&lt;/li&gt;
&lt;li&gt;No max length (more on handling that later)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Password should not be on the top 1,000 (or more) most common passwords list

&lt;ul&gt;
&lt;li&gt;Load a text file during the &lt;code&gt;Init()&lt;/code&gt; of your &lt;a href=&#34;http://tech.townsourced.com/post/anatomy-of-a-go-web-app/#the-app-package&#34;&gt;app layer&lt;/a&gt; and
test new passwords against it.&lt;/li&gt;
&lt;li&gt;Update the password file yearly. A good source I&amp;rsquo;ve found is &lt;a href=&#34;https://github.com/robsheldon/bad-passwords-index&#34;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thats it.&lt;/p&gt;

&lt;p&gt;Simple requirements are easier for your users to understand, easier for you to manage, and easier for you to rip out and
rewrite when technology inevitably changes.&lt;/p&gt;

&lt;p&gt;Recommended reading:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nakedsecurity.sophos.com/2016/08/18/nists-new-password-rules-what-you-need-to-know/&#34;&gt;New NIST Guidelines for Passwords&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.codinghorror.com/your-password-is-too-damn-short/&#34;&gt;Your Password is Too Damn Short&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;There are a lot of discussions around whether you should hash your passwords using bcrypt or scrypt.  If you are debating
between these two, then you are off to a good start.  &lt;a href=&#34;https://yahoo.tumblr.com/post/154479236569/important-security-information-for-yahoo-users&#34;&gt;Yahoo&lt;/a&gt;
was apparently using MD5.  Personally I went with bcrypt, but both scrypt and bcrypt give you good protections against
modern attacks (with the ability to increase the work factor), while doing away with unneeded aspects of password management
like salting.&lt;/p&gt;

&lt;p&gt;However, there is one aspect of bcrypt and scrypt that you need to be careful of.  By their very nature, these hashing
algorithms take time and resources to process.  They do this to make it hard to run large dictionary attacks.  But this
also leaves your web application vulnerable to a potential denial of service attack if a user submits a very large
password.  To protect against this, you could set a max possible length for user&amp;rsquo;s passwords, but that goes in the face
of the rule above: &lt;em&gt;Long passwords are better than complex passwords&lt;/em&gt;.  Instead, we can pass the password through a sha512
sum, to guarantee that only 512 bits ever get passed through to bcrypt or scrypt.&lt;/p&gt;

&lt;p&gt;Below is the implementation of this (with the optional third party authentication) in &lt;a href=&#34;https://www.townsourced.com&#34;&gt;townsourced&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package app

...


/// UserLogin logs in a user via their password and either their username or email
func UserLogin(usernameOrEmail, password string) (*User, error) {
	u := &amp;amp;User{}
	if strings.Contains(usernameOrEmail, &amp;quot;@&amp;quot;) {
		//login with email
		err := data.UserGetEmail(u, usernameOrEmail)
		if err == data.ErrNotFound {
			return nil, ErrUserEmailNotFound // can test for email, but not username
		}
		if err != nil {
			return nil, err
		}
	} else {
		// login with username
		err := data.UserGet(u, data.NewKey(usernameOrEmail))
		if err == data.ErrNotFound {
			// don&#39;t expose that user doesn&#39;t exist
			// a bad password and an incorrect username should look the same
			return nil, ErrUserLogonFailure 
		}
		if err != nil {
			return nil, err
		}
	}
	if u.HasPassword == false || len(u.Password) == 0 {
		//User isn&#39;t a password based user, and can&#39;t login with a password
		// they need to use facebook/google/twitter
		return nil, ErrUserLogonFailure
	}
	err := u.login(password)
	if err != nil {
		return nil, err
	}
	return u, nil
}

func (u *User) login(password string) error {
	if !u.HasPassword || len(u.Password) == 0 {
		if u.GoogleID == &amp;quot;&amp;quot; &amp;amp;&amp;amp; u.FacebookID == &amp;quot;&amp;quot; &amp;amp;&amp;amp; u.TwitterID == &amp;quot;&amp;quot; {
			return ErrUserLogonFailure
		}
		// Can&#39;t auth password for non-password based users
		return nil
	}

	// sha512 password and compare
	shaPass := sha512.Sum512([]byte(password))

	err := bcrypt.CompareHashAndPassword(u.Password, shaPass)
	if err != nil {
		if err == bcrypt.ErrMismatchedHashAndPassword {
			return ErrUserLogonFailure
		}
		return err
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dropbox does something similar with their passwords, and they have a good writeup of their implementation here:
&lt;a href=&#34;https://blogs.dropbox.com/tech/2016/09/how-dropbox-securely-stores-your-passwords/&#34;&gt;https://blogs.dropbox.com/tech/2016/09/how-dropbox-securely-stores-your-passwords/&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;password-resets-forgotten-passwords&#34;&gt;Password Resets / Forgotten Passwords&lt;/h3&gt;

&lt;p&gt;Notice above, how there is no mention of security questions, or password hints.  This is on purpose.  Some of the biggest,
most public &amp;ldquo;hacks&amp;rdquo; that you&amp;rsquo;ll read about online are almost always due to taking over accounts by looking up or guessing
answers to security questions.  The much safer, and simpler way for users to recover passwords is to use a recovery email
request.&lt;/p&gt;

&lt;p&gt;Generate a unique random token (make sure to use &lt;a href=&#34;https://golang.org/pkg/crypto/rand/&#34;&gt;crypto/rand&lt;/a&gt; not
&lt;a href=&#34;https://golang.org/pkg/math/rand/&#34;&gt;math/rand&lt;/a&gt;) and email it to the &lt;em&gt;previously verified&lt;/em&gt; email address of your user.
In the email have the unique token passed through a URL that triggers a password reset if the token is valid.  Tokens
should be usable once only, and should eventually expire if not used.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;//Random returns a random, url safe value of the bit length passed in
func Random(bits int) string {
	result := make([]byte, bits/8)
	_, err := io.ReadFull(rand.Reader, result)
	if err != nil {
		panic(fmt.Sprintf(&amp;quot;Error generating random values: %v&amp;quot;, err))
	}
	return base64.RawURLEncoding.EncodeToString(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;session-management&#34;&gt;Session Management&lt;/h2&gt;

&lt;p&gt;Now that you&amp;rsquo;ve authenticated your user, you&amp;rsquo;ll want to create a session so that they don&amp;rsquo;t need to re-login on every
request.  Just like with forgotten passwords and OAUTH, you&amp;rsquo;ll be creating a unique, cryptographically random, and expire-
able token to identify a session.  You&amp;rsquo;ll store that token in a cookie in the browser, and force an early expiration
when the user logs out.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what the complete Session type looks like in &lt;a href=&#34;https://www.townsourced.com&#34;&gt;townsourced&lt;/a&gt;.  You&amp;rsquo;ll notice there is
a bit more in there besides just the token (SessionID) and expiration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package app

...


// Session is an authenticated session into townsourced
type Session struct {
	Key       string //userkey+sessionID 
	UserKey   data.Key
	SessionID string  
	CSRFToken string
	Valid     bool
	Expires   time.Time
	When      time.Time
	IPAddress string
	UserAgent string


	user *User // cached user struct, to prevent repeated DB lookups
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a user successfully authenticates, you can create a new session and store it in your database.  This session will
be looked up on every request, so if you run into performance issues, you should consider storing it in a caching layer.
In townsourced, I used &lt;a href=&#34;https://memcached.org/&#34;&gt;memcached&lt;/a&gt;, but there are many options available, just as long as the
caching layer is available to &lt;em&gt;all&lt;/em&gt; of your web servers, otherwise if a user gets load-balanced to a different web
server, it&amp;rsquo;ll look like they&amp;rsquo;ve been logged out.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package app

...

// SessionNew generates a new session for the passed in user
func SessionNew(user *User, expires time.Time, ipAddress, userAgent string) (*Session, error) {
	if expires.IsZero() {
		expires = time.Now().AddDate(0, 0, 3) // default expiration
	}
	s := &amp;amp;Session{
		UserKey:   user.Username,
		SessionID: Random(128),
		CSRFToken: Random(256),
		Valid:     true,
		Expires:   expires,
		When:      time.Now(),
		IPAddress: ipAddress,
		UserAgent: userAgent,
	}

	s.Key = string(s.UserKey) + &amp;quot;_&amp;quot; + s.SessionID
	err := data.SessionInsert(s, s.Key, s.Expires)
	if err != nil {
		return nil, err
	}
	return s, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once your session is created in the back-end, you can store your new session in a cookie in the user&amp;rsquo;s browser.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package web

...

func setSessionCookie(w http.ResponseWriter, r *http.Request, u *app.User, rememberMe bool) error {
	expires := time.Time{}
	if rememberMe {
		expires = time.Now().AddDate(0, 0, 15)
	}
	s, err := app.SessionNew(u, expires, ipAddress(r), r.UserAgent())
	if err != nil {
		return err
	}
	cookie := &amp;amp;http.Cookie{
		Name:     cookieName, // const of your app name
		Value:    s.Key,
		HttpOnly: true, 
		Path:     &amp;quot;/&amp;quot;,
		Secure:   isSSL, // global var set if running ssl
		Expires:  expires,
	}
	http.SetCookie(w, cookie)
	return nil
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then on each request, you can check if the session is valid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package web

...

// get a session from the request
func session(r *http.Request) (*app.Session, error) {
	// must iter through all cookies because you can have
	// multiple cookies with the same name
	// the cookie is valid only if the name matches AND it has a value
	cookies := r.Cookies()
	cValue := &amp;quot;&amp;quot;
	for i := range cookies {
		if cookies[i].Name == cookieName {
			if cookies[i].Value != &amp;quot;&amp;quot; {
				cValue = cookies[i].Value
			}
		}
	}
	if cValue == &amp;quot;&amp;quot; {
		return nil, nil
	}
	s, err := app.SessionGet(cValue)
	if err == app.ErrSessionInvalid {
		return nil, nil
	}
	return s, err
}

...

package app

...

// SessionGet retrieves a session
func SessionGet(sessionKey string) (*Session, error) {
	s := &amp;amp;Session{}
	err := data.SessionGet(s, sessionKey)
	if err == data.ErrNotFound {
		return nil, ErrSessionInvalid
	}
	if err != nil {
		return nil, err
	}
	if !s.Valid || s.Expires.Before(time.Now()) {
		return nil, ErrSessionInvalid
	}
	return s, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how you track expiration on both the client &lt;em&gt;and&lt;/em&gt; the server.  Never trust anything from the client.&lt;/p&gt;

&lt;p&gt;If the client wants to log off, you simply expire the session early (or mark it invalid if you want to preserve the
original expiration date).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package web

func logout (w http.ResponseWriter, r *http.Request, s *app.Session) {
	cookie, err := r.Cookie(cookieName)
	if err != http.ErrNoCookie {
		if cookie.Value == s.Key {
			// clear value, and set maxAge: 0
			cookie := &amp;amp;http.Cookie{
				Name:     cookieName,
				Value:    &amp;quot;&amp;quot;,
				HttpOnly: true,
				Path:     &amp;quot;/&amp;quot;,
				Secure:   isSSL,
				MaxAge:   0,
			}
			http.SetCookie(w, cookie)
		}
	}

	if errHandled(c.session.Logout(), w, r, c) {
		return
	}
}

...

package app

// Logout logs out of a session
func (s *Session) Logout() error {
	s.Valid = false
	return s.put()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it.  You should have the basics of managing user authentication in a Go web app.  If you skimmed this post, your
biggest takeaway should be to not manage passwords, or at the very least, provide your users with the more secure option
of using Facebook, Google, or Twitter to authenticate with your app.&lt;/p&gt;

&lt;p&gt;The specifics of this post were requested on &lt;a href=&#34;https://www.reddit.com/r/golang/comments/5h6rvh/anatomy_of_a_go_web_application/&#34;&gt;reddit&lt;/a&gt;,
so if there are any other topics you&amp;rsquo;d like covered, or if you found this post helpful, feel free to leave me a comment,
or shoot me a message.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Anatomy of a Go Web Application</title>
      <link>http://tech.townsourced.com/post/anatomy-of-a-go-web-app/</link>
      <pubDate>Sun, 04 Dec 2016 10:37:07 -0600</pubDate>
      
      <guid>http://tech.townsourced.com/post/anatomy-of-a-go-web-app/</guid>
      <description>&lt;p&gt;When building a web application from scratch, there are a lot of decisions to make.  The goal of this guide is to give
one more example of how you can go about building a web application in the Go language, as well as to give you an idea
what things you need to start thinking about and plan for before you get started.&lt;/p&gt;

&lt;p&gt;This guide is not intended to be exhaustive, nor is it absolute. It is a compendium of the things I thought about and how I dealt
with them when building &lt;a href=&#34;https://www.townsourced.com&#34;&gt;townsourced.com&lt;/a&gt;.  Hopefully you&amp;rsquo;ll find it useful.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;package-layout-and-code-organization&#34;&gt;Package Layout and Code Organization&lt;/h1&gt;

&lt;p&gt;Clean separation of duties, and clear code boundaries are crucial to figure out when building large applications.  I&amp;rsquo;ve
found, with web applications, these the 3 package delineations are required:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#the-web-package&#34;&gt;web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-app-package&#34;&gt;app&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-data-package&#34;&gt;data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There may be others, but for the most part your code will fall into one of these 3 packages, or sub-packages
within them.&lt;/p&gt;

&lt;p&gt;But, before we get into packages, we need to setup the main entry point to our program.  In Go, this means &lt;code&gt;func main()&lt;/code&gt;
and I usually put mine in &lt;code&gt;main.go&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;main-go&#34;&gt;main.go&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;main.go&lt;/code&gt; will be responsible for loading anything configurable in your web app and passing those configuration options
into the other layers.  There are many different options for storing your app&amp;rsquo;s configuration, personally I store mine
in json files using a &lt;a href=&#34;https://github.com/timshannon/config&#34;&gt;small configuration library&lt;/a&gt; I wrote.  If you want many options
including environment variables, TOML, YAML, or JSON , check out  Steve Francia&amp;rsquo;s excellent &lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Below is an example of townsourced&amp;rsquo;s config file to give you an idea of the types of options you may put in there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
    &amp;quot;app&amp;quot;: {
        &amp;quot;httpClientTimeout&amp;quot;: &amp;quot;30s&amp;quot;, 
        &amp;quot;taskPollTime&amp;quot;: &amp;quot;1m&amp;quot;,
        &amp;quot;taskQueueSize&amp;quot;: 100
    },
    &amp;quot;data&amp;quot;: {
        &amp;quot;cache&amp;quot;: { // memcached servers
            &amp;quot;addresses&amp;quot;: [
                &amp;quot;127.0.0.1:11211&amp;quot;
            ]
        },
        &amp;quot;db&amp;quot;: { // RethinkDB 
            &amp;quot;address&amp;quot;: &amp;quot;127.0.0.1:28015&amp;quot;,
            &amp;quot;database&amp;quot;: &amp;quot;townsourced&amp;quot;,
            &amp;quot;timeout&amp;quot;: &amp;quot;60s&amp;quot;
        },
        &amp;quot;search&amp;quot;: {  // ElasticSearch
            &amp;quot;addresses&amp;quot;: [
                &amp;quot;http://127.0.0.1:9200&amp;quot;
            ],
            &amp;quot;index&amp;quot;: {
                &amp;quot;name&amp;quot;: &amp;quot;townsourced&amp;quot;,
                &amp;quot;replicas&amp;quot;: 1,
                &amp;quot;shards&amp;quot;: 5
            },
            &amp;quot;maxRetries&amp;quot;: 0
        }
    },
    &amp;quot;web&amp;quot;: {
        &amp;quot;address&amp;quot;: &amp;quot;http://localhost:8080&amp;quot;,
        &amp;quot;certFile&amp;quot;: &amp;quot;&amp;quot;, 
        &amp;quot;keyFile&amp;quot;: &amp;quot;&amp;quot;,
        &amp;quot;maxHeaderBytes&amp;quot;: 0,
        &amp;quot;maxUploadMemoryMB&amp;quot;: 10,
        &amp;quot;minTLSVersion&amp;quot;: 769,
        &amp;quot;readTimeout&amp;quot;: &amp;quot;60s&amp;quot;,
        &amp;quot;writeTimeout&amp;quot;: &amp;quot;60s&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I defined this configuration as separate structs in each package: &lt;code&gt;web.Config&lt;/code&gt;, &lt;code&gt;app.Config&lt;/code&gt;, and &lt;code&gt;data.Config&lt;/code&gt;.
You&amp;rsquo;ll then load the configuration into these structs, and pass them into their respective packages. This is also a good
time to initialize any clients in those packages as well.  In Townsourced, this looks like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package data

type Config struct {
	DB      DBConfig     `json:&amp;quot;db&amp;quot;`
	Cache   CacheConfig  `json:&amp;quot;cache&amp;quot;`
	Search  SearchConfig `json:&amp;quot;search&amp;quot;`
}

// DefaultConfig returns the default configuration for the data layer
func DefaultConfig() *Config {
	return &amp;amp;Config{
		DB: DBConfig{
			Address:  &amp;quot;127.0.0.1:28015&amp;quot;,
			Database: DatabaseName,
			Timeout:  &amp;quot;60s&amp;quot;,
		},
		Cache: CacheConfig{
			Addresses: []string{&amp;quot;127.0.0.1:11211&amp;quot;},
		},
		Search: SearchConfig{
			Addresses:  []string{&amp;quot;http://127.0.0.1:9200&amp;quot;},
			MaxRetries: 0,
			Index: SearchIndexConfig{
				Name:     &amp;quot;townsourced&amp;quot;,
				Shards:   5,
				Replicas: 1,
			},
		},
	}
}

func Init(cfg *Config) error {
	// initialize rethinkdb, memcached and elasticsearch clients based on passed in config
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Config is then loaded and passed into the &lt;code&gt;data&lt;/code&gt; layer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// main.go

package main

func main() {
	...

	settingPaths := config.StandardFileLocations(&amp;quot;townsourced/settings.json&amp;quot;)
	cfg, err := config.LoadOrCreate(settingPaths...)
	if err != nil {
		app.Halt(err.Error())
	}

	...

	dataCfg := data.DefaultConfig()

	err = cfg.ValueToType(&amp;quot;data&amp;quot;, dataCfg)
	if err != nil {
		app.Halt(&amp;quot;Error reading data config values: %s&amp;quot;, err.Error())
	}

	err = cfg.Write()
	if err != nil {
		app.Halt(&amp;quot;Error writing config file to %s. Error: %s&amp;quot;, cfg.FileName(), err)
	}

	err = data.Init(dataCfg)
	if err != nil {
		log.Fatalf(&amp;quot;Error initializing townsourced data layer: %s&amp;quot;, err.Error())
	}

	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-web-package&#34;&gt;The Web Package&lt;/h2&gt;

&lt;p&gt;The &lt;strong&gt;web&lt;/strong&gt; package is the client&amp;rsquo;s entry point to your application.  Here you will extensively use the &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;http package&lt;/a&gt;
and the &lt;a href=&#34;https://golang.org/pkg/encoding/json&#34;&gt;encoding/json package&lt;/a&gt; for any REST APIs.&lt;/p&gt;

&lt;p&gt;You will process cookies at this level and pass already extracted session identifies to your application layer.  The http
package and its types and interfaces (requests, writers, cookies, etc.) should never leave this package.  Or to put it
another way, you shouldn&amp;rsquo;t need to import http in &lt;em&gt;any&lt;/em&gt; other packages except this one.  Preventing the http package from
leaking into other packages will help keep the responsibilities of http handling clearly defined &lt;em&gt;only&lt;/em&gt; in the web package.&lt;/p&gt;

&lt;h2 id=&#34;the-app-package&#34;&gt;The App Package&lt;/h2&gt;

&lt;p&gt;The &lt;strong&gt;app&lt;/strong&gt; package is where the meat of your application will be.  Inside this package you&amp;rsquo;ll define exported types
that will be passed to and from your other packages; types like &lt;code&gt;app.User&lt;/code&gt; and &lt;code&gt;app.Session&lt;/code&gt;.  The point of the app package
is to validate and handle data within these types, so most of your code in the app package will be methods on types, or
functions that return these types. Be conservative about which types and methods you choose to export.  The web package
doesn&amp;rsquo;t need to understand how an &lt;code&gt;app.User&lt;/code&gt; is approved to see data, it just needs to know whether they can or not.&lt;/p&gt;

&lt;p&gt;More likely than not your application data will be related to each other.  Try to retrieve types from their relationships
with other types rather than from standalone functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;	//  instead of this
	func UserFromSession(s *Session) (*User, error) {

	}

	// do this
	func(s *Session) User() (*User, error){

	}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If standalone functions are necessary or make more sense (for instance when they don&amp;rsquo;t actually modify any type data),
then don&amp;rsquo;t export them.&lt;/p&gt;

&lt;p&gt;If you aren&amp;rsquo;t careful you may find yourself implementing parts of your application in the web or data layers when they
should be in the app layer; for example, access controls.&lt;/p&gt;

&lt;p&gt;You may be tempted to check if a user has access to some data at the web layer, but this type of access control should
always be done at the app layer, where it can be easily found, and unit tested.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// instead of this

package web

func handler(w http.ResponseWriter, r *http.Request) {
	if currentUser.Equal(userBeingViewed) {
		profile, err := userBeingViewed.Profile()
	}
}

// do this

package app

func (u *User) Profile(who *User) (*ProfileData, error) {
	if !u.equal(who) {
		return nil, errors.New(&amp;quot;You do not have access to view this profile!&amp;quot;)
	}

	return &amp;amp;ProfileData{}, nil
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-data-package&#34;&gt;The Data Package&lt;/h2&gt;

&lt;p&gt;The data package is for getting and setting data in your persistent and temporary storage.  There shouldn&amp;rsquo;t be any types
kept here unless they are types that augment the data layer.  For example, you shouldn&amp;rsquo;t see a &lt;code&gt;User&lt;/code&gt; or &lt;code&gt;Session&lt;/code&gt; in the
data layer, but you may see a type called &lt;code&gt;UUID&lt;/code&gt; that exists within the &lt;code&gt;app.User&lt;/code&gt; or &lt;code&gt;app.Session&lt;/code&gt; types.&lt;/p&gt;

&lt;p&gt;A specific example of this in &lt;a href=&#34;https://www.townsourced.com&#34;&gt;Townsourced&lt;/a&gt; is the &lt;code&gt;data.Version&lt;/code&gt; type which looks like
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type Version struct {
	VerTag  string   // Unique, random value identifying this version
	Created time.Time // When this record was first created
	Updated time.Time // when this record was last updated
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This Version type is then embedded in other types to easily track when objects are created and updated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type User struct {
	Username       data.Key        
	Email          string         
	...
	data.Version
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The real usefulness of &lt;code&gt;data.Version&lt;/code&gt;, and the reason it exists in the &lt;code&gt;data&lt;/code&gt; package is its ability to prevent any
updates running in the data layer if the &lt;code&gt;vertag&lt;/code&gt; being submitted by the user doesn&amp;rsquo;t match the &lt;code&gt;vertag&lt;/code&gt; in of the
record in the database, preventing your users from updating an entry based on stale data.&lt;/p&gt;

&lt;p&gt;Another example of the data layer&amp;rsquo;s responsibilities is cache invalidation. In Townsourced, the code to determine when to
invalidate and update &lt;em&gt;memcached&lt;/em&gt; entries exists in the &lt;code&gt;data&lt;/code&gt; layer, not the &lt;code&gt;app&lt;/code&gt; layer.  The &lt;code&gt;app&lt;/code&gt; layer shouldn&amp;rsquo;t
worry about &lt;em&gt;how&lt;/em&gt; data is stored or retrieved, it should only concern itself with the structure and behavior of its types.&lt;/p&gt;

&lt;h2 id=&#34;putting-it-all-together&#34;&gt;Putting it all together&lt;/h2&gt;

&lt;p&gt;At this point your web application should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;webapp
|--main.go
|
|--app
|   |--user.go
|   |--session.go
|   |--whatever.go
|   
|--data
|   |--data.go
|   |--version.go
|   
|--web
    |--server.go
    |--json.go

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main.go&lt;/code&gt; imports &lt;code&gt;web&lt;/code&gt;, &lt;code&gt;app&lt;/code&gt;, and &lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;web&lt;/code&gt; imports &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app&lt;/code&gt; imports &lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;error-handling&#34;&gt;Error Handling&lt;/h1&gt;

&lt;p&gt;Handling errors properly is important in any application, but especially so in web applications where your users may be
anyone from a 90 year old grandmother trying to get to facebook from your website, or a sophisticated hacker who&amp;rsquo;s bored
and looking for an easy target.&lt;/p&gt;

&lt;p&gt;In web applications, errors tend to happen in one of two ways: the system broke or the user broke the system. Conveniently
http has already given us status code ranges to differentiate between the two types of errors:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Status 400 range - User Errors&lt;/li&gt;
&lt;li&gt;Status 500 range - Server Errors&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If the user breaks the system by putting in bad input using the web application in a way that wasn&amp;rsquo;t intended, they should
be notified of the mistake with a clear explanation of what went wrong and how.  I refer to these errors as &lt;strong&gt;Failures&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;If the system breaks (due to network, hardware, or system design issues) the user should &lt;em&gt;not&lt;/em&gt; be given any details.
Any information returned as to the cause of the error is a potential security issue where you may be leaking private
details of your server architecture, configuration vulnerabilities, or specific library versions which could then be
used to attack your application in a specific way.&lt;/p&gt;

&lt;p&gt;To help manage which errors should be visible to users and which shouldn&amp;rsquo;t, I usually create a &lt;code&gt;fail&lt;/code&gt; package, which
resides outside the existing packages. It exists outside the main packages, because failures may happen in any
of them.  Inside the &lt;code&gt;fail&lt;/code&gt; package is the &lt;code&gt;fail.Fail&lt;/code&gt; type which implements the &lt;code&gt;error&lt;/code&gt; interface, so it can be
returned like a normal error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type Fail struct {
	Message    string      `json:&amp;quot;message,omitempty&amp;quot;`
	Data       interface{} `json:&amp;quot;data,omitempty&amp;quot;`
	HTTPStatus int         `json:&amp;quot;-&amp;quot;` //gets set in the error response
}

func (f *Fail) Error() string {
	return f.Message
}

// IsFail tests whether the passed in error is a failure
func IsFail(err error) bool {
	if err == nil {
		return false
	}
	switch err.(type) {
	case *Fail:
		return true
	default:
		return false
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When errors bubble up to the &lt;code&gt;web&lt;/code&gt; package, you can use a &lt;a href=&#34;https://golang.org/doc/effective_go.html#type_switch&#34;&gt;type switch&lt;/a&gt;
to determine which are failures that can be shown to the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;errMsg := &amp;quot;&amp;quot;

switch err.(type) {
case *fail.Fail:
	errMsg = err.Error()
case *http.ProtocolError, *json.SyntaxError, *json.UnmarshalTypeError:
	//Hardcoded error types which can bubble up to the end users
	// without exposing internal server information, make them behave like failures
	err = fail.NewFromErr(err)
	errMsg = fmt.Sprintf(&amp;quot;We had trouble parsing your input, please check your input and try again: %s&amp;quot;, err)
default:
	errMsg = &amp;quot;An internal server error has occurred&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tips-and-tricks&#34;&gt;Tips and Tricks&lt;/h1&gt;

&lt;h2 id=&#34;json-input&#34;&gt;JSON Input&lt;/h2&gt;

&lt;p&gt;When handling JSON input, such as for an API, be wary of Go&amp;rsquo;s &lt;a href=&#34;https://golang.org/ref/spec#The_zero_value&#34;&gt;zero values&lt;/a&gt;.
In an API you need to be able to tell the difference between setting a value to a zero value, and not setting a value at
all. Consider the following scenario.  Let&amp;rsquo;s say you have an API where the user can set their Name or the Email Address,
you may define the input like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type UserInput struct {
	Email string
	Name  string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a user just wants to update their Name and not their Email, they&amp;rsquo;ll send some JSON like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Javascript&#34;&gt;{ Name: &amp;quot;New Name&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which, when parsed, will result in &lt;code&gt;Name == &amp;quot;New Name&amp;quot;&lt;/code&gt; and &lt;code&gt;Email == &amp;quot;&amp;quot;&lt;/code&gt;.  You don&amp;rsquo;t know if the user meant to set their
email to &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; or if they simply didn&amp;rsquo;t specify any change to their Email.&lt;/p&gt;

&lt;p&gt;You should instead define your input with pointers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type UserInput struct {
	Email *string
	Name  *string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way you can check if Email was set to &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; or if it wasn&amp;rsquo;t specified at all:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;if input.Email != nil {
	//update email
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be careful to check each input though, so you don&amp;rsquo;t run into any nil pointer panics.&lt;/p&gt;

&lt;h2 id=&#34;development&#34;&gt;Development&lt;/h2&gt;

&lt;p&gt;When developing your web application, you need to see immediate feedback from the changes you&amp;rsquo;re making.  This means seeing
the results of your work without having to restart your web server.  For this reason it&amp;rsquo;s important to create a &lt;em&gt;dev mode&lt;/em&gt;
in your application that can be turned on via a command line flag, or environment variable.  Once set, you can use this
variable to rebuild templates on every request, reload files on every request, watch for file changes and auto-reload
the web page. You&amp;rsquo;d be surprised how much your productivity can suffer with a long write and evaluate loop.  In my
opinion it&amp;rsquo;s worth spending time getting this working as soon as possible.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func (t templateHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if devMode || t.template == nil {
		t.loadTemplates()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sync-pool&#34;&gt;sync.Pool&lt;/h2&gt;

&lt;p&gt;When each connection comes in on its own separate go-routine, the easiest way to write your code is create and destroy
everything you need within that go-routine.  This will work for a while, but eventually, if your request load starts
increasing you&amp;rsquo;ll start running into issues with garbage collection.  Most of the time, the answer to that problem is
&lt;code&gt;sync.Pool&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, if you want to gzip every response, your first pass may have you creating a new gzip writer on every request.
If your server gets a huge spike in traffic, then your server will be spending a lot of time reclaiming unused gzip writers
when things start to die down.&lt;/p&gt;

&lt;p&gt;Instead, you can use &lt;code&gt;sync.Pool&lt;/code&gt; to instantiate your gzip writers, and when you&amp;rsquo;re done with them, put them back in the
pool to be reused, instead of garbage collected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func init() {
	zipPool = sync.Pool{
		New: func() interface{} {
			return gzip.NewWriter(nil)
		},
	}
}

...

// custom response writer
type gzipResponse struct {
	zip *gzip.Writer
	http.ResponseWriter
}

func (g *gzipResponse) Write(b []byte) (int, error) {
	if g.zip == nil {
		return g.ResponseWriter.Write(b)
	}
	return g.zip.Write(b)
}

// http server calls Close() on the responseWriter
// return the gzip writer to the pool
func (g *gzipResponse) Close() error {
	if g.zip == nil {
		return nil
	}
	err := g.zip.Close()
	if err != nil {
		return err
	}
	zipPool.Put(g.zip)
	return nil
}

func responseWriter(w http.ResponseWriter, r *http.Request) *gzipResponse {
	var writer *gzip.Writer
	if strings.Contains(r.Header.Get(&amp;quot;Accept-Encoding&amp;quot;), &amp;quot;gzip&amp;quot;) {
		w.Header().Set(&amp;quot;Content-Encoding&amp;quot;, &amp;quot;gzip&amp;quot;)
		gz := zipPool.Get().(*gzip.Writer)
		gz.Reset(w)
		writer = gz
	}
	return &amp;amp;gzipResponse{zip: writer, ResponseWriter: w}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;As you can see from the length of this post, there are a lot of things to consider when building a web application, and
I&amp;rsquo;ve only just scratched the surface of the topic.  Hopefully this post can act as a foundation to start from, as well
as a base to refer to in future posts about more specific aspects of web application development in Go.&lt;/p&gt;

&lt;p&gt;I hope you find this post useful, and if you have any corrections, questions, or suggestions for future posts, let me
know in the comments below.&lt;/p&gt;

&lt;p&gt;* edit &lt;a href=&#34;http://tech.townsourced.com/post/anatomy-of-a-go-web-app-authentication&#34;&gt;Part 2: Authentication&lt;/a&gt; has since been written.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>